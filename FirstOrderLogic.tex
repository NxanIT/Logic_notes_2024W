\chapter{Predicate - / first order logic}
\defin{A First order Language}{
    consists of infinetely many distinct symbols such that no symbol is a proper 
    initial segment of another symbol and the symbols are divided into 2 groups:
    \begin{enumerate}
        \item logical symbols\outernote{logical symbols}\\
        (These elements have a fixed meaning and the equivalence symbol $=$ is optional)
        \begin{flalign*}
            (,),\lnot, \to, v_1,v_2,\dots,=&&
        \end{flalign*}
        \item parameters\outernote{parameters}
        \begin{itemize}
            \item quantifier symbol: $\forall$ (the range is subject of interpretation)
            \item predicate symbols: for every $n>0$ we have a set of $n$-ary predicates $P$
            \item constant symbols: Some set of constants (could also be $\varnothing$)
            \item function symbols: for every $n>0$ we have a set of $n$-ary function symbols
        \end{itemize}
    \end{enumerate}
}
\note{}{
    \begin{itemize}
        \item We could drop constants and instead introduce $0$-ary function symbols
        \item to specify language we need to specify the parameters and say if $=$ is included
        \item In the book \cite{EndertonHerbertB2001AMIt} they assume that
        some $n$-place predicate symbol is present for some $n$.
    \end{itemize}
}
\bsp{}{
    \begin{itemize}
        \item $\mathcal{L}_\text{set} = \{\in\}$, \quad $=$ included and the binary predicate symbol $\in$ "element in"
        \item $\mathcal{L}_\text{arith} = \{<,0,S,E,+,\cdot\}$
        \begin{itemize}
            \item [$=$] included
            \item [$<$] is a binary rel. symbol
            \item [$0$] is a constant
            \item [$S$] is a unary function symbol
            \item [$E$] exponentiation function symbol
            \item [$+,\cdot$] binary function symbols
        \end{itemize}
        \item $\mathcal{L}_\text{ring} = \{=,+,\cdot,-,0,1\}$
        \begin{itemize}
            \item [$=$] included
            \item [$0,1$] are constants
            \item [$-$] is a unary function symbol (additive inverse)
            \item [$+,\cdot$] binary function symbols
        \end{itemize}
    \end{itemize}
}

\section{Formulas}
\defin{Expression}{An \graybf{expression} is any finite sequence of symbols.
    There exist two kinds of expressions that makes sense "grammatically"
    \begin{itemize}[leftmargin=1.6cm]
        \item[Terms:] \begin{itemize}
            \item points to an object
            \item they are built up from variables and constants using function symbols %(by use of polish notation)
        \end{itemize}
        \item[Formulas:]\begin{itemize}
            \item They express assertions about objects,
            \item they are built up from atomic formulas 
            \item atomic formulas these are built up from terms using predicate symbols and $=$, if included
        \end{itemize}
    \end{itemize}
}
\defin{Term Building Operations}{
    For every $n>0$ and for every $n$-place function symbol $f$ let $\mathcal{F}_f$ be an $n$-place term building operation,
    that is $\mathcal{F}_f (t_1,\dots t_n)\defeq ft_1,\dots t_n$ (polish notation for $f(t_1,\dots t_n)$).
    The Set of terms\outernote{term}we then define as the set of expressions that are built up from variables and constants by applying the term building operations
    finitely many times.
}
\bsp{}{Let $\mathcal{L} = \mathcal{L}_{arith}$ then the set of terms will contain $0$, $v_{42}$, $S0$, $SSS0$, $Sv_1$, $+SOv_1$}
\defin{Atomic formula}{Any expression of the form 
    $$=t_1t_2 \text{ or } Pt_1,\dots t_n, \text{ where $t_1,\dots t_n$ are terms and $P$ is an $n$-ary predicate symbol}$$}
\note{}{Atomic formulas are not defined inductively.}
\bsp{}{\emph{cont.}\quad $=v_1 v_{42}$, $<S0 SS0$ are atomic formulas, but $\lnot = v_1 v_{42}$ is not.}
\defin{Formulas}{We define $\varepsilon_\lnot$, $\varepsilon_\to, Q_i$ to be the fla. building operations, defined as follows
    $\varepsilon_\lnot(\alpha) \defeq (\lnot \alpha)$, $\varepsilon_\to \defeq (\alpha \to \beta)$ and
    $Q_i(\gamma) \defeq \forall v_i \gamma$.
    The set of formulas\outernote{formula}is the set of expressions built up from atomic formulas by applying the fla. building operations finitely many times.
}
\bsp{}{\emph{cont.} $\forall v_1 (=Sv_10)$ is a formula we get by applying $Q_1$ on the atomic formula $=Sv_1 0$.}
\subsubsection*{Free variables}
\bsp{}{We introduce the $\exists$\outernote{$\exists$ quantifier} quantifier by defining $\exists y \alpha$ means $\lnot \forall y \lnot \alpha$.\\
    "Every non-zero natual number is a succsesor" $\forall x (x\neq 0\to \exists y S(y)=x)$
    is different then "if a number is not $0$, then it is a succsesor" $x\neq 0\to \exists y S(y)=x$. 
    $x$ occurs bounded\outernote{bounded variable} in the first formula, for the latter $x$ occures free in the fla.

    If you have an expression without free variables, it is either true or false, on the other hand
    if a variable occurs free in a formula, the truth value of it depends on the variable itself.
}
\defin{Free variables}{
    Let $x$ be a variable. $x$ occurs \graybf{free in $\varphi$} is defined inductively as follows:
    \begin{enumerate}
        \item If $\varphi$ is an atomic fla. then $x$ occurs \graybf{free} in $\varphi$ iff $x$ occurs in $\varphi$
        \item If $\varphi = (\lnot \alpha)$ then $x$ occurs free in $\varphi$ iff $x$ occurs free in $\alpha$
        \item If $\varphi = (\alpha \to \beta)$ then $x$ occurs free in $\varphi$ iff $x$ occurs free in $\alpha$ or $\beta$
        \item If $\varphi = \forall v_i \alpha$ then $x$ occurs free in $\varphi$ iff $x$ occurs free in $\alpha$ and $x\lnot v_i$
    \end{enumerate}
    A formula $\alpha$ is called a sentence,\outernote{sentence}if no variable occurs free in $\alpha$
}
\note{}{The above definition makes sense thanks to the recursion theorem.
    define the function $h$ on the set of atoms: $h(\alpha) = \text{the set of var occ in fla } \alpha$, which is the set of all variables $v_i$ that occur free in $\alpha$.
    we now want to extend $h$ to $\overline{h}$, which is the set of all formulas.
    \begin{itemize}
        \item $\overline{h}(\lnot \alpha) = \overline{h}(\alpha)$
        \item $\overline{h}( \alpha \to \beta) = \overline{h}(\alpha)\cup \overline{h}(\beta)$
        \item $\overline{h}(Q_i(\alpha)) = \overline{h}(\alpha)\backslash \{v_i\}$
    \end{itemize}
    We say $x$ occurs free in $\alpha$ iff $x\in \overline{h}(\alpha)$.
}
\note{}{We will now use $\lnot, \land,\lor,\to, \leftrightarrow, \exists v_i$ (all can be expressed in terms of $\lnot,\to,Q_i$.)
    We will sometimes drop the $(,)$ and not always be using polish notation.
}
\section{Semantics of first order logic}
The equivalent scheme to our TA in predicate logic. The meaning of formulas is given by \emph{structures}, 
which also determine the scope of the quantifier $\forall$, the meaning of all parameters.
\defin{structure}{A \graybf{structure} $\mathfrak{A}$ for a first order language $\mathcal{L}$ is a non-empty set
    set $A$ called \graybf{universe} or \graybf{underlying set of $\mathfrak{A}$} together with an interpretation of each parameters of $\mathcal{L}$ i.e.
    \begin{itemize}
        \item $\forall$ ranges over the universe $A$
        \item for an $n$-ary pred. symbol $P\in \mathcal{L}$ its interpretation $P^\mathfrak{A}$ is a subset of $A^n$\outernote{interpretation}
        \item for a constant $c\in \mathcal{L}$ its interpretation $c^\mathfrak{A}$ is an element of $A$
        \item for an $n$-ary function symbol $f\in \mathcal{L}$ its interpretation $f^\mathfrak{A}$ is a total function $$f^\mathfrak{A}: A^n \to A$$
    \end{itemize}
}
\note{}{$A\neq \varnothing$, and all functions $f^\mathfrak{A}$ are total.}
\bsp{}{Let $\mathcal{L} = \{\in\}$ where $\in$ is a binary relation "
    An example of an $\mathcal{L}$ structure is $(\NN, \in^\NN)$ where $\in^\NN = \{(x,y)\in \NN^2 : x<y\}$}
\defin{Assigment}{Let $\varphi$ be a $\mathcal{L}$-fla. and $\mathfrak{A}$ a $\mathcal{L}$-structure. 
    Let $V$ be the set of all variables in $\mathcal{L}$ and $s:V\to A$ an assignment.\outernote{assigment}
    We define the extention $\overline{s}$ of $s$ to the set of all $\mathcal{L}$-terms by
    \begin{itemize}
        \item if $x\in V$ then $\overline{s}(x) \defeq s(x)$
        \item for $c\in \mathcal{L}$ a constant symbol, then $\overline{s}(c) \defeq c^\mathfrak{A}$
        \item for $t_1,\dots t_n$ $\mathcal{L}$-terms and $f\in \mathcal{L}$ an $n$-ary function symbol, then 
        $$\overline{s}(ft_1\dots t_n) \defeq f^\mathfrak{A}(\overline{s}(t_1),\dots \overline{s}(t_n))$$
    \end{itemize}
}

\note{}{in the previous definition point 3. for $n=1$ yields a commutative diagram.

}
\prop{}{For any given assignment $s$ there exists a unique extention $\overline{s}$ as in the previous definition.}
{
    will follow from recursion theorem and unique decomposition of terms.
}
\newpage
\subsection*{Definition of truth}
\defin{Satisfy}{ We define '$\mathfrak{A}$ satisfies $\varphi$ with $s$' and write
    $\mathfrak{A}\models \varphi \:[s]$\outernote{$\models_\mathfrak{A}$} or $\models_\mathfrak{A} \varphi \:[s]$ inductively over the complexity of the formula $\varphi$
    \begin{enumerate}
        \item if $\varphi$ is atomic: \begin{itemize}
            \item $\mathfrak{A} \models\: = t_1,t_2 \: [s]$ iff $ \overline{s}(t_1) = \overline{s}(t_2)$
            \item $\mathfrak{A} \models P t_1,\dots t_n \: [s]$ iff $(\overline{s}(t_1),\dots \overline{s}(t_2))\in P^\mathfrak{A}$
        \end{itemize}
        \item suppose $\mathfrak{A}\models \varphi \: [s]$ and $\mathfrak{A}\models \psi \: [s]$ are defined, then
        \begin{itemize}
            \item $\mathfrak{A}\models \lnot\varphi \: [s]$ iff $\mathfrak{A}\nvDash \varphi \: [s]$
            \item $\mathfrak{A}\models \varphi\to \psi \: [s]$ iff $\mathfrak{A}\models \psi \: [s]$ or $\mathfrak{A}\nvDash  \varphi \: [s]$
            \item $\mathfrak{A}\models \forall x \varphi \: [s]$ iff for all $a\in A$ $\mathfrak{A}\models \varphi [s(x| a)]$
            where 
            \begin{equation*}
                s(x|a)(v) = \begin{cases}
                s(v) \text{ if } v \neq x\\
                a \text{ if } v = x
            \end{cases}
            \end{equation*}
            
        \end{itemize}
    \end{enumerate}
}
\bsp{}{
    $\mathcal{L} = \{\forall, \leq, S, 0\}$ 
    a $\mathcal{L}$-structure then could be $\mathfrak{N} = (\NN,\leq^\mathfrak{N},S^\mathfrak{N},0^\mathfrak{N})$ together with an assignment
    $s: v_n \mapsto n-1$ then:
    \begin{itemize}
        \item $s(v_1) = 0$
        \item $\overline{s}(0) = 0^\mathfrak{N}$ (a constant is always mapped to its realisation, the interpretation of constant $0$ in the structure $\mathfrak{N}$)
        \item $\overline{s}(Sv_1) = S^\mathfrak{N}(\overline{s}(v_1)) = S^\mathfrak{N}(0) = 1$\\
        \item $\mathfrak{N}\models \forall v_1 (S(v_1) \neq v_1) \: [s]$\\
            iff for all $a\in \NN$ we have that $\mathfrak{N}\models (S(v_1) \neq v_1) [s(v_1 | a)]$\\
            iff \dots \\
            iff for all $a\in \NN$ we have $S^\mathfrak{A}(a) \neq a$, which is true in our structure of the natural numbers.
        \item Is it true in $\mathfrak{N}$ that $\mathfrak{N}\models S(0) \leq S(v_1) \: [s]$? Yes because
        \begin{equation*}
            \begin{split}
                &\mathfrak{N}\models S(0) \leq S(v_1) \: [s] \\
                &\iif \: 1\leq 1
            \end{split}
        \end{equation*}
        
    \end{itemize}
}
\note{}{To know wheter $\mathfrak{A}\models \varphi \: [s]$ it suffices to know where $s$ maps the variables that are free in $\varphi$}

\prop{}{\label{Thm.evalonlyfreevar}Suppose $s_1,s_2:V\to A$ agree on all variables that occur free in $\varphi$ then 
 $$\mathfrak{A}\models \varphi \:[s_1] \text{ iff }\mathfrak{A}\models \varphi \: [s_2]$$
}{
    By complexity of $\varphi$
    \begin{enumerate}
        \item if $\varphi$ is $P t_1,\dots t_n$ 
        note: any var that occur in $\varphi$ occur free in $\varphi$, so $s_1,s_2$ agree on all variables that occur in the terms $t_1,\dots t_n$.\\
        So we Claim: for $t$ a term, $s_1,s_2$ assignments that agree on all variables of $t$ then $\overline{s}_1(t) = \overline{s}_2(t)$
        \begin{claimproof}
            By complexity of $t$
            \begin{itemize}
                \item $t = v_m$ then  $\overline{s}_1(t) ={s}_1(v_m) = {s}_2(v_m) =\overline{s}_2(t)$
                \item $t = c$ then  $\overline{s}_1(t) =c^\mathfrak{A} =\overline{s}_2(t)$
                \item $t = ft_1\dots t_n$ inductively, assume $\overline{s}_1(t_i) =\overline{s}_2(t_i)$ for all $1\leq i\leq n$ then  TODO
            \end{itemize}
        \end{claimproof}
        \item if $\varphi$ is $ =t_1,t_2$ is similar
        \item if $\varphi$ is $\lnot \alpha$ then $\mathfrak{A}\models \lnot \alpha  \: [s_1]$ iff $\mathfrak{A}\vDash \alpha  \: [s_1]$iff $\mathfrak{A}\vDash \alpha  \: [s_2]$ iff $\mathfrak{A}\models \lnot \alpha  \: [s_1]$
        \item if $\varphi$ is $\alpha \to \beta$ then $\mathfrak{A}\models  \alpha \to \beta  \: [s_1]$ iff .. or .. iff for s2 iff ... or .. 
        \item if $\varphi$ is $ \forall x \alpha$ then the assumption is that $s_1,s_2$ .. the free variables of $\alpha$ are the free variables of $\varphi$ exept for $x$.
        but because $s_1(x|a) = s_2(x|a)$ they both agree on all free variables of $\alpha$.
        \[\begin{split}
            \mathfrak{A}\models \forall x \varphi  \: [s_1] &\iif \fora a\in A \mathfrak{A}\models \varphi  \: [s_1(x| a)]\\
            & \iif \fora a\in A \mathfrak{A}\models \varphi  \: [s_2(x| a)]\\
            & \iif \mathfrak{A}\models \forall x \varphi  \: [s_2]
        \end{split}\]
    \end{enumerate}
    
}
Notation: $\mathfrak{A}\models \varphi $TODO means that all free variables of $\varphi$ are among $v_1,\dots v_n$ and $\mathfrak{A}\models \varphi \: [s]$ whenever $s(v_i) = a_i$ for all $1\leq i\leq n$.
\coroll{If $\sigma$ is a sentence then $\mathfrak{A}\models \sigma \: [s]$ for all $s:V\to A$ or 
$\mathfrak{A}\vDash \sigma \: [s]$ for all $s:V\to A$.

Notation: $\mathfrak{A}\models \sigma$ "$\sigma$ is true in $\mathfrak{A}$, $\mathfrak{A}$ is a model of $\sigma$ or $\sigma$ holds in $\mathfrak{A}$.
}
\note{}{If $\sigma$ is a sentence then we can not have  $\mathfrak{A}\models \sigma$ and  $\mathfrak{A}\vDash \sigma$ because $A\neq \varnothing$.}
\defin{Model}{$\mathfrak{A}$ is a model of a set of sentences $\Sigma$ iff for every sentence $\sigma\in \Sigma$ it holds  $\mathfrak{A}\models \sigma$ }
\bsp{}{$\mathcal{L} = \{0,1,+,-,\cdot\}$
A realisation could be $\mathfrak{R} = (\RR, 0,1,+,-,\cdot)$ or $\mathcal{C} = (\mathbb{C}, 0,1,+,-,\cdot)$
then the sentence 
$\sigma: \quad \exists x (x\cdot x = -1)$ then $\mathfrak{R}\vDash \sigma$ but $\mathcal{C}\models \sigma$

}
\note{}{$\land,\lor,\leftrightarrow,\exists$ work as expected. That is 
 $\mathfrak{A}\models (\alpha \land \beta) \: [s]$ iff $\mathfrak{A}\models \alpha \: [s]$ and $\mathfrak{A}\models \beta \: [s]$
 $\mathfrak{A}\models (\alpha \lor \beta) \: [s]$ iff $\mathfrak{A}\models \alpha \: [s]$ or $\mathfrak{A}\models \beta \: [s]$
 $\mathfrak{A}\models \exists x \alpha \: [s]$ iff $\mathfrak{A}\models \lnot \forall x \lnot \alpha \: [s]$\\
 iff $\mathfrak{A}\vDash \forall x \lnot \alpha \: [s]$\\
 iff it is not true that forall $a \in A$ $\mathfrak{A}\models \lnot \alpha [s(x|a)]$\\
 iff there is $a\in A$ such that $\mathfrak{A}\models \alpha [s(x|a)]$
}


\section{Logical implication}
Let $\Gamma$ be a set of $\mathcal{L}$-formulas, $\varphi$ a $\mathcal{L}$-formula.
\defin{Logical implication}{
    $\Gamma \models \varphi$ "$\Gamma$ logically implies $\varphi$" if for every $L$-structure $\mathfrak{A}$ and for every $s:V\to A$ 

    if $\mathfrak{A}\models \gamma \: [s]$for every $\gamma \in \Gamma$  then $\mathfrak{A}\models \varphi \: [s]$

}

\defin{Logical equivalence}{$\varphi,\psi$ are called logically equivalent if 
$\varphi \models \psi$ and $\psi \models \varphi$.
}
\defin{Valid}{$\varphi$ is called valid iff $\models \varphi$ i.e. $\varnothing\models \varphi$ i.e. for every $\mathcal{L}$-structure $\mathfrak{A}$ and every $s:V\to A$ it is $\mathfrak{A}\models \varphi \: [s]$
}
\bsp{}{
\begin{enumerate}
    \item $\forall x_1 P x_1 \models P x_2$\\
    Suppose $\mathfrak{A}\models \forall x_1 P x_1 \: [s]$.
    then for all $a\in A$ it is $\mathfrak{A}\models P x_1 [s(x_1|a)]$ in particular, $a\in P^\mathfrak{A}$ for $a = s(x_2)$
    \item  $\forall P x_2 \vDash \forall x_1 P x_1$\\
    We need a counterexample to $\forall P x_2 \models \forall x_1 P x_1$. Let $A = \{a_1,a_2\}$ $s(x_2) = a_1$ and $P^\mathfrak{A} = \{a_1\}$
    then $\mathfrak{A}\models Px_2 \: [s]$.
    \item Is the following valid? $\models \exists x(Px \to \forall y P y)$ yes
    \item $\Gamma,\alpha\models \varphi$ iff $\Gamma \models \alpha \to \varphi$. (on next problem set, quite impoirtant)
\end{enumerate}
}

\section{definability in a structure}
\defin{definability in a structure}{ 
    We say that a general $n$-ary relation $P$ on $A$ (we will just call it $P$, it does not have to be in the language) is definable in $\mathfrak{A}$, if there is a $\mathcal{L}$-formula
    $\varphi$ with free variables among $\{v_1,\dots,v_n\}$ such that 
    \[P = \{(a_1,\dots a_n) : \mathfrak{A} \models \varphi\: \llbracket a_1,\dots a_n\rrbracket\}\]
    We also say that $\varphi$ defines $P$ in the structure $\mathfrak{A}$.
}
\bsp{}{
    \begin{enumerate}
        \item $x = x$ would define the entire universe.
        \item $\lnot x = x$ would define the empty set.
    \end{enumerate}
}
\bsp{}{
\begin{enumerate}
    \item TODO
    \item $\mathfrak{R} = (\RR,0,1,+,-,\cdot)$ Q: is $[0,\infty)$ definable in $\mathfrak{R}$
    Yes because $\exists y (y\cdot y = x)$
    Indeed we can even define the $\leq$ relation on $\RR^2$ by $x\leq z \defaq \exists y (x+y\cdot y = z)$ 
\end{enumerate}
}
\defin{definability of classes of structures}{
    Let $\Sigma$ be a set of sentences. $\tau$ a sentence.
    We will say that the class of models of $\Sigma$ is the class $\Mod \Sigma =\{\mathfrak{A} : \mathfrak{A}\models \Sigma\}$.
    Let $K$ be a class of structures. We are going to call $K$ an elementary class (EC) if there is a single sentence $\tau$ such that $K = \Mod \tau$.
    $K$ is called an elementary class in the wider sence (EC$_\Delta$) if there is a set of sentences $\Sigma$ such that $K = \Mod \Sigma$

}
\bsp{}{$\mathcal{L} = \{0,1,+,\cdot\}$ 
    $\tau$ is a sentence that expresses the field axioms (the unary inverse functions are not in our language but are definable.)
    $\Mod \tau$ is the class of all the fields, which is EC.
    the class of all fields of characteristic $0$. Let $\sigma_p: \lnot(1 + \dots +1 = 0)$ then $\Sigma = \{\tau\} \cup \{\sigma_p : p\in \mathbb{P}\}$ 
    yields $\Mod \Sigma$ is the class of fields with characteristic $0$, therefore EC$_\Delta$, we will later see that it is not $EC$.

}
\bsp{}{
    Let $E$ be a binary relation, $\mathcal{L} = \{E\}$ then a graph is a realisation $\mathfrak{G} = (V,E^\mathfrak{G})$ 
    such that $v\neq \varnothing$, $E^\mathfrak{G}$ is irreflexive and symmetric.
    By definition the universe is not empty, we still have to check irreflexive and symmetric.
    \begin{itemize}
        \item irreflexive: $\forall x (\lnot x E x)$
        \item symmetric: $\forall x \forall y (x E y \to y E x)$
    \end{itemize}
    We take $\tau$ to be $\forall x \forall y ((\lnot x E x)\land (x E y \to y E x))$
    Then $\Mod \tau$ is the class of all graphs and is EC
    Note: the class of all finite graphs is neither EC nor EC$_\Delta$. proof later.
}
We want to have some notion that tells us when two graphs are the same or at least similar.
\section{Homomorphisms of structures}
\defin{Homomorphism}{
    Suppose that $\mathfrak{A},\mathfrak{B}$ are two $\mathcal{L}$-structures. then a Homomorphism of $\mathfrak{A}$ into $\mathfrak{B}$ is a map
    $h: A \to B$ that satisfy the below conditions
    \begin{itemize}
        \item for every $n$-ary predicate $P\in \mathcal{L}$ it is $(a_1,\dots a_n)\in P^\mathfrak{A}$ iff $(h(a_1),\dots h(a_n))\in P^\mathfrak{B}$ (this def. a strong Homomorphism, other textbooks maybe only reqire $\to$ direction)
        \item for every $n$-ary function $f\in \mathcal{L}$ and for all $\underline{a} = (a_1,\dots a_n)\in A^n$ it holds $h(f^\mathfrak{A}(\underline{a})) = f^\mathfrak{B}(h(a_1),\dots h(a_n))$
        \item for every constant symbol $c\in \mathcal{L}$ it is $h(c^\mathfrak{A}) = c^\mathfrak{B}$ (could also skip this if we consider constants as $0$-ary functions)
    \end{itemize}
}
\note{}{Intuativly a Homomorphism of $\mathfrak{A}$ into $\mathfrak{B}$ is a map $A \to B$ that preserve all funciton and relation symbols in some sense, (imp: not the definable relations)}
\defin{Isomorphism}{
    \begin{itemize}
        \item $h:A\to B$  is called isomorphism of $\mathfrak{A}$ into $\mathfrak{B}$ if $h$ is a Homomorphism and injective (in other textbooks: an isomorphic embedding of $\mathfrak{A}$ into $\mathfrak{B}$)
        \item $h:A\to B$  is called isomorphism of $\mathfrak{A}$ onto $\mathfrak{B}$ if $h$ is a Homomorphism and bijective $A\to B$
        \item \outernote{isomorphic}$\mathfrak{A}$ and $\mathfrak{B}$ are called isomorphic if there is an isomorphism of $\mathfrak{A}$ onto $\mathfrak{B}$
    \end{itemize}
}
\note{}{
    %TODO: in general 
}
\bsp{}{
    $\mathcal{L}= \{+,\cdot\}$
    $\mathfrak{N} = (\NN, +^\NN, \cdot^\NN)$ and $\mathfrak{B} = (B,+^\mathfrak{B},\cdot^\mathfrak{B})$ where $B = \{0,1\}$ and 
    \begin{tabular}{c|c c}
        $+^\mathfrak{B}$ & $e$ & 0\\\hline
        $e$ & $e$ & 0\\
        0 & 0 & $e$
    \end{tabular}
    \begin{tabular}{c|c c}
        $\cdot^\mathfrak{B}$ & $e$ & 0\\\hline
        $e$ & $e$ & $e$\\
        0 & $e$ & 0
    \end{tabular}
    let $h:\NN \to B$ a Homomorphism?
    $h(n) = \begin{cases}
        e & \text{ if $n$ is even}\\
        0 & \text{ else}
    \end{cases}$
    need at first that $h(m+n ) = h(m) +^\mathfrak{B} h(n)$
    and $h(m\cdot n) = h(m)\cdot^\mathfrak{B} h(n)$.
    it is indeed a Homomorphism.
}
\defin{Substructure}{Suppose we have two $\mathcal{L}$ structures and $A\subseteq B$ hen $\mathfrak{A}$ is a substructure of $\mathfrak{B}$ 
    (notation: $\mathfrak{A}\subseteq \mathfrak{B}$ or we might say $\mathfrak{B}$ is an extention of $\mathfrak{A}$ ) if
    \begin{itemize}
        \item for every $n$-ary relation $P^\mathfrak{A} = P^\mathfrak{B}|_A$
        \item for every $n$-ary function $f^\mathfrak{A} = f^\mathfrak{B}|_A$
        \item for every constant symbol $c$ in $\mathcal{L}$ it is $c^\mathfrak{A} = c^\mathfrak{B}$
    \end{itemize}
}
\bsp{}{
    $\mathcal{L} = \{\leq\}$ then $\mathfrak{N} = (\NN, \leq)$ and $\mathcal{P} = (\NN^+, \leq ^\mathcal{P})$ where $\leq^\mathcal{P}$ is the restriction of $\leq$ to the positive natual numbers.
    $\mathcal{P} \subseteq \mathfrak{N}$ and there exists a isomorphic embedding $id: \NN^+\to \NN$ from $\mathcal{P}$ into $\mathfrak{N}$
    They are even isomorphic ($h:\NN \to \NN^+, h(n) = n+1$) so in fact $\mathcal{P} \cong \mathfrak{N}$.
}
\bsp{}{
    $(\mathbb{Q},+)\subseteq(\mathbb{C},+)$
}
\note{}{If $\mathfrak{A}\subseteq \mathfrak{B}$ then in particular $\mathfrak{A}$ is closed under all constant and functions in $\mathfrak{B}$
    So suppose that $\mathfrak{B}$ is a substructure and $A\subseteq B$ and $A\neq \varnothing$ and $A$ is closed under $f^\mathfrak{B}$, $c^\mathfrak{B}$ 
    Can then $A$ be made into a substructure $\mathfrak{A}$ of $\mathfrak{B}$.
    $f^\mathfrak{A}$ would be the restriction of $f^\mathfrak{B}$ to $A^n$, constants $c^\mathfrak{A} = c^\mathfrak{B}$ 
    and if $P \in \mathcal{L}$ is an $n$-ary predicate then $P^\mathfrak{A}$ should be $P^\mathfrak{B}\cap A^n$.
    If $\mathcal{L}$ has no const. or fuction symbols then any subset can be made into a substructure of a structure on $\mathcal{L}$.
}
Our next question will be: what is the relation of the above notions with truth and satisfiability
The answer will be given by the so called Homomorphism theorem.

\prop{Homomorphism theorem}{
    $h$ homomorphism of $\mathfrak{A}$ into $\mathfrak{B}$, $s:V\to A$ then
    \begin{enumerate}
        \item for all terms $t$ it is $h(\overline{s}(t))=\overline{(h\circ s)}(t)$
        \item $\varphi$ a fla. that is quantifier free and does not include $=$ then $\mathfrak{A}\models \varphi \: [s]$ iff $\mathfrak{B}\models \varphi  \: [h\circ s]$
        \item if $h$ is additionally injective then we can drop the requirement " no $=$".
        \item if $h$ is homomorphism of $\mathfrak{A}$ onto $\mathfrak{B}$ then we can drop the requirement "q.f." in (b)
    \end{enumerate}
}{
    \begin{enumerate}
        \item problem set
        \item \begin{itemize}
            \item $\varphi: Pt$ then $\mathfrak{A}\models Pt \: [s]$ iff $\overline{s}(t)\in P^\mathfrak{A}$ iff $h(\overline{s}(t))\in P^\mathfrak{B}$ iff $\overline{(h\circ s)}(t)\in P^\mathfrak{B}$ 
            iff $\mathfrak{B}\models Pt  \: [h\circ s]$
            \item $\varphi: \lnot \psi$ $\mathfrak{A}\models \lnot \psi \: [s]$ iff $\mathfrak{A}\vDash \psi \: [s]$ iff $\mathfrak{A}\vDash \psi \: [s]$ iff %TODO
            \item $\varphi: \psi \to \alpha$
        \end{itemize}
        \item $\mathfrak{A}\models =t_1t_2 \: [s]$ iff $\overline{s}(t_1)=\overline{s}(t_2)$ iff $h(\overline{s}(t_1))=h(\overline{s}(t_2))$ iff (by (a))$\overline{(h\circ s)}(t_1) = \overline{(h\circ s)}(t_2)$ 
        iff $\mathfrak{B}\models =t_1t_2 \: [h\circ s]$
        \item $\varphi$ $ \forall s: V\to A$ $\mathfrak{A}\models \varphi \: [s]$ iff $\mathfrak{B}\models \varphi  \: [h\circ s]$, want $\mathfrak{A}\models \forall x \varphi \: [s]$ iff 
        $\mathfrak{B}\models \forall x \varphi  \: [h \circ s]$
        1. $\mathfrak{B}\models \forall x \varphi  \: [(h\circ s)]$
        iff for all $s:V\to A$, $a\in A$ (req. surjectivity) it is $\mathfrak{B}\models \varphi  \: [(h\circ s)(x | h(a))]$
        iff $\mathfrak{B}\models \varphi  \: [h\circ (s(x |a))]$
        iff (inductive assumption)$\mathfrak{A}\models \varphi  \: [s(x|a)]$ because $a$ was arbitrary it is $\mathfrak{A}\models \forall x \varphi \: [s]$
        2. Suppose $\mathfrak{B}\vDash \forall x \varphi  \: [(h\circ s)]$ then there exists a $b\in B$ such that $\mathfrak{B}\models \lnot \varphi  \: [(h\circ s)(x | b)]$
        by surjectivity we can find $a\in A$ such that $h(a)=b$ and it is $\mathfrak{B}\models \lnot \varphi  \: [(h\circ s)(x | h(a))]$
        By the inductive assumption $\mathfrak{A}\models \lnot \varphi  \: [s(x|a)]$ and $\mathfrak{A}\vDash \forall x \varphi \: [s]$
    \end{enumerate}
}
\note{}{$\mathfrak{A}\cong \mathfrak{B}$ then $\mathfrak{A}$ and $\mathfrak{B}$ satisfy exactly the same sentences.}
\defin{elementarily equivalent}{$\mathfrak{A}$ and $\mathfrak{B}$ are called elementarily equivalent ($\mathfrak{A}\equiv \mathfrak{B}$) if $\mathfrak{A}$ and $\mathfrak{B}$ satisfy the same sentences.}
\note{}{If $\mathfrak{A}\cong \mathfrak{B}$ implies $\mathfrak{A}\equiv \mathfrak{B}$
    The converse is not true.
    For instance DLO (dence linear order) w/o endpoints is complete, so two structures on DLO are equivalent 
    $(\mathbb{Q},<)\equiv (\RR,<)$ but they are not isomorphic because the universes have diffrent cardinality. 
}
\bsp{}{
    $\mathfrak{N} = (\NN, \leq)$ and $\mathcal{P}=(\NN^{>0},\leq )$ $h:n\mapsto n-1:\mathcal{P}\to \mathfrak{N}$ isom. 
    so in part $\mathfrak{N} \equiv \mathcal{P}$.
    but $id:\mathcal{P}\to \mathfrak{N}$ is only isom embedding, so for example
    $\forall y(x\neq y x\leq y)$  
    $\mathcal{P}\models \alpha  \: [1]$ but $\mathfrak{N}\nvDash \alpha  \: [1]$
    but $\mathfrak{N}\models \alpha  \: [h(1)]$
}
\defin{Automorphism}{An automorphism is an isomorphism of the form $h:A\to A$ from $\mathfrak{A}$ onto $\mathfrak{A}$}
\note{}{Every structure has a trivial automorphism $id:A\to A$}
\defin{Rigid}{If the only automorphism on $\mathfrak{A}$ is the trivial automorphism, then $\mathfrak{A}$ is called rigid.}
\bsp{}{ If every element is definable then the structure is rigid.
    For example $(\NN,0,S)$ and $(\NN,<)$ every element is definable, therefore the structures are rigid.
    %TODO examples structures with many automorphism
    }
\coroll{
    Let $h$ be atutom of $\mathfrak{A}$, $R\subseteq A^n$ definable in $\mathfrak{A}$ then $\forall a\in A^n a\in R \iif (h(a_1),\dots h(a_n))\in R$ 
    Suppose $\varphi$ defines $R$ in $\mathfrak{A}$ we want
    $\mathfrak{A}\models \varphi \: [a]$ iff  $\mathfrak{A}\models \varphi \: [h(a_1),\dots h(a_n)]$ which is true by the homom. thm.
}
\note{}{Corol can be used to show that some $R\subseteq A^n$ is not definable in $\mathfrak{A}$
}
\bsp{}{
    $\mathfrak{R}=(\RR,<)$ then $\NN$ is not definable in $\mathfrak{R}$.
    What do automorphisms of $\mathfrak{R}$ look right? 
    $h:\RR\to \RR$ is a bijection and $x<y$ iff $h(x)<h(y)$ so $h$ is strictly increasing.
    for example $x\mapsto x+ \frac{1}{2}$ or $x\mapsto x^3$.  
}
\section{Unique readability for terms}
\defin{}{
    We define $K$ on symbols from which terms are built up(variables, constants, function symbols).
    $K(s) = 1-n$ where $s$ is a symbol and $n$ is the number of terms that need to follow s in order to obtain a term.
    $K(x) = 1 = K(c)$ and $K(f) = 1-n$ where f is an $n$-ary funciton symbol
    We now extend $K$ to the set of all expressions which are built up from above symbols (variables, constants, function symbols):
    $K(s_1,\dots s_n) = K(s_1) + \dots + K(s_n)$ (unique because no symbol is a finite sequence of other symbols)
}
\lemma{}{
    $t$ a term then $K(t)=1$
}{
    $K(x) = 1 = K(c)$ and $K(ft_1,\dots t_n) = 1-n + n = 1$ 
}
\defin{}{A terminal segment of string of symbols $(s_1,\dots s_n)$ is $(s_k,s_{k+1},\dots s_n)$ for some $1\leq k\leq n$.}
\lemma{}{Any terminal segment of terms is a concatenation of one or more terms.}{
    True for variables and constants. 
    $ft_1\dots t_n$ the only non trivial case is $t'_k t_{k+1}\dots t_m$ where $t_k$ is $t''_k t_k'$
}
\coroll{If $t_1$ is a proper initial segment of a term $t$ then 
 its $K(t_1)<1$. proof:
    let $t$ be $t_1 t_2$ where $t_1$ is a proper initial segment then $K(t) = 1$ and $K(t_2)\geq1$ therefore $K(t_1)\leq 0$
}
\subsubsection{Unique readability for terms}
The set of terms is freely generated from the set of variables(Var), the set of constant symbols (Const) by the term building operations $\mathcal{F}_f$ for the function symbols $f$.
\begin{proof}
    
     \begin{itemize}
        \item disjointment of ranges: Let $f$ and $g$ be two distinct funciton symbols then $\rng\mathcal{F}_f \cap \rng\mathcal{F}_g =\varnothing$
        $\rng\mathcal{F}_f \cap Var =\varnothing$
        $\rng\mathcal{F}_f \cap Const =\varnothing$
        \item $\mathcal{F}_f|_{\text{terms}}$ are 1-1:
        assume $ft_1\dots t_n = f t'_1\dots t'_n$ and assume $t_1 \neq t_1'$ then one is an initial segment of the other.
        Then its $K$-value has to be less than $1$ so it is not a term.
        $t_1 = t_1' \dots t_n=t_n'$.
     \end{itemize}
\end{proof}
\defin{}{Extend $K$ as follows: $K(() = -1$ $K()) = 1$ $K(\forall) = 1$ $K(\lnot) = 0$ $K(\to) = -1$ $K(P) = 1-n$ for an $n$-ary rel. symb. $P$. $K(=) = -1$.
    Extend $K$ to the set of all expressions by $K(s_1,\dots s_n) = K(s_1) + K(s_n)$
    The idea is that $K$ tells us the number of symbols that at least need to follow to obtain a formula.
}
\lemma{}{
    for every formula $\varphi$ it is $K(\varphi) = 1$
}{
    induction on $\varphi$
}
\lemma{}{for every proper initial segment $\alpha'$ of a fla. $\alpha$ we have $K(\alpha')<1$}{}
\coroll{No proper initial segment of a fla. is a fla.}
The set of flas. is freely generated from the set of atomic flas. by operations $\mathcal{E}_\lnot,\mathcal{E}_\to,Q_i$
\begin{proof}
    \begin{itemize}
        \item $\mathcal{E}_\lnot,Q_i$ are one to one
        \item $\mathcal{E}_\to|_{\text{Flas.}}$ then itemwise and use of prev. lemmas
        \item p.w. disjointness of ranges
    \end{itemize}
\end{proof}

\section{A parsing algorithm for first order logic}

\section{Deductions (formal proofs)}
\defin{Modus Ponens}{Rule of interference: $$\frac{\alpha, \alpha\to \beta}{\beta}$$

}
\defin{}{A formal proof (decuction) of a fla $\varphi$ from a set of formulas $\Sigma$ is a finite sequence of formulas 
    $(\alpha_0,\alpha_1,\dots,\alpha_n)$ such that $\alpha_n = \varphi$ and for every $i<n$ $\alpha_i$ is either a logical axiom or $\alpha_i\in\Sigma$ or 
    $\alpha_i$ is obtained from $\alpha_k$ and $\alpha_l$ where $0\leq k,l<i$ by the use of MP, in particular $\alpha_k = \beta \to \alpha_i$ and $\alpha_l = \beta$.
    If a deduction of $\varphi$ from $\Sigma$ exists, we say "$\varphi$ is deducible from $\Sigma$" or "$\varphi$ is a theorem of $\Sigma$".
}
\note{}{Deductions are not unique. However we do have an induction principle:
    If a set of formulas contains all logical axioms and all of $\Sigma$ and is closed under MP, then it contains all theorems of $\Sigma$.
}
\subsubsection{Logical axioms}
\defin{Generalization}{$\psi$ is a generalization of $\varphi$ if $\psi = \forall x_{i_1}\dots \forall x_{i_k} \varphi$ 

}
\defin{Logical axioms}{Let $x,y$ be variables and $\alpha, \beta$ formulas. then the logical axioms are generalizations of the following formulas:
    \begin{enumerate}
        \item tautologies
        \item $\forall x \alpha \to \alpha_t^x$ where $t$ is substitutable for $x$ in $\alpha$ 
        \item $\forall x (\alpha \to \beta) \to (\forall x \alpha \to \forall x \beta)$
        \item $\alpha\to \forall x \alpha$ where $x$ does not occur free in $\alpha$
    \end{enumerate}
    if our language contains $=$ then 
    \begin{enumerate}
        \item $x=x$ 
        \item $x=y \to (\alpha \to \alpha')$ where $\alpha'$ is obtained from $\alpha$ by replacing some of the occurences of $x$ with $y$.
    \end{enumerate}
    
}
Ad $2)$ Substitution: 
\defin{}{Let $\alpha,\beta$ be formulas, $x$ a variable and $t$ a term then $\alpha_t^x$ is expression obtained from $\alpha$ by substituting $t$ for $x$ 
    We define substitution inductive as follows:
    \begin{enumerate}
        \item if $\alpha$ is atomic then $\alpha = \text{expression obtained from $\alpha$ by replacing all $x$'s by $t$'s
        }$
        \item $(\lnot \alpha)^x_t = \lnot (\alpha^x_t)$
        \item $( \alpha\to \beta)^x_t = (\alpha^x_t)\to  (\beta^x_t)$
        \item $(\forall y \alpha)^x_t = \begin{cases}
            \forall y  (\alpha^x_t) &\text{ iff } x\neq y\\
            \forall x \alpha &\text{ iff } x=y
        \end{cases}$
    \end{enumerate}
}
\bsp{}{
    \begin{itemize}
        \item $ \alpha^x_x = \alpha$
        \item Let $\alpha = \lnot \forall y x = y$ what is $\forall x \alpha \to   \alpha^x_z$?
        \[\forall x \lnot \forall y x=y \leadsto \lnot \forall y z=y\]
        What is $\forall x \alpha \to \alpha_y^x$
        $\forall x \lnot \forall y x=y$ is true in all structures with a universe $A$ with $|A|\geq 2$.
        \[\forall x \lnot \forall y x=y\leadsto  \lnot \forall y y = y\]
        and $\lnot \forall y y = y$ is an antitautology (it is always false).
        \item 
    \end{itemize}
}
So we have to define substitutable
\defin{}{\addAbbrev{SA}{substitutable}
    Let $x$ be a variable, $t$ a term. Then $t$ is substitutable for $x$ in $\alpha$ if
    \begin{enumerate}
        \item $\alpha$ atomic then $t$ is SA for $x$ in $\alpha$
        \item then $t$ is SA for $x$ in $\lnot \alpha$ iff then $t$ is SA for $x$ in $\alpha$
        \item then $t$ is SA for $x$ in $\alpha\to \beta$ iff then $t$ is SA for $x$ in $\alpha$ and $\beta$
        \item then $t$ is SA for $x$ in $\forall y \alpha$ iff either
        \begin{itemize}
            \item $x$ does not occur free in $\forall y \alpha$ or
            \item $y$ does not occur in $t$ and $t$ is SA for $x$ in $\alpha$
        \end{itemize}
    \end{enumerate}
}
\bsp{}{For instance the following is a logical axiom.
    \[\forall x_3 (\forall x_1 (Ax_1 \to \forall x_2 Ax_2)\to (Ax_2\to \forall x_2 A x_2))\]
    It is a generalization of $\forall x_1 (Ax_1 \to \forall x_2 Ax_2)\to (Ax_2\to \forall x_2 A x_2)$
    which is by point two a substitution with $\alpha = Ax_1 \to \forall x_2 Ax_2$. Then $\alpha_{x_2}^{x_1} = Ax_2\to \forall x_2 A x_2$
    And $x_2$ is indeed substitutable for $x_1$ in $\alpha$ because it does not get bounded.
    
    \[\forall x_1 (\forall x_2 B x_1 x_2 \to \forall x_2 B x_2 x_2)\]
    is a generalization of point (2), but $x_2$ is not substitutable for $x_1$ in $\alpha = $, therefore it is not a logical axiom.
}
\subsubsection{Ad (1): tautologies}
\defin{}{Tautologies are the formulas obtained from tautologies of propositional logic by replacing all propositional atoms by formulas of first order logic.
    
    An alternative definition is:
    Divide all formulas of first order logic into two groups:
    \begin{enumerate}
        \item atomic formulas and generalizations of first order formulas (these are called prime formulas)
        \item all other formulas i.e. of the form $\lnot \alpha$ and $\alpha \to \beta$ (non-prime formulas)
    \end{enumerate}
    So any first order formula is built up from the prime formulas using finitly many times the formula building operations. $\mathcal{E}_\lnot$ $\mathcal{E}_\to$ 
    We have unique readability because the set of formulas is freely generated.
}
\bsp{}{\[\lnot (\forall y (Px \to Py))\to (Px\to \forall y \lnot Py)\]
is built up from $\lnot (\forall y (Px \to Py))$ and $Px\to \forall y \lnot Py$.
which itself $\forall y (Px \to Py)$ and 
$Px$ and $\forall y \lnot Py$ where they are all prime formulas.
}
\bsp{}{Is the following a tautology?
\[(\forall y (\lnot Py)\to \lnot Px)\to (Px\to \lnot\forall y \lnot Py)\]
We construct the construction tree into prime formulas and then assign truth values to them and evalue the truth value of the whole formula.
It is indeed a tautology.
}
\note{}{
    \begin{itemize}
        \item $\forall x(Px \to Px)$ is a prime formula which corresponds to a propositional atom, and therefore not a tautology.
But it is a generalization of a tautology and therefore by (1) a logical axiom.
        \item $\forall x Px \to Px$ is not a tautology but is a logical axiom by group (2).
    \end{itemize}
}
\note{}{
    $\Gamma \models_{\text{taut}} \varphi$ from propositional logic can be translated to first order logic.
}
\lemma{}{If $\Gamma\models_{\text{taut}}\varphi$ then $\Gamma \models\varphi$}{
    Problem set.
}
\note{}{The converse fails. For instance $\forall x Px \models Pc$. However $Pc$ is a diffrent propositional atom 
then $\forall x Px $ they have no connection between them when viewed in propositional logic. 

We will prove $\Gamma\models \varphi$ iff $\Gamma\vdash \varphi$ (the first direction is completeness and the converse soundness.)}
\prop{}{$\Gamma\vdash \varphi$ iff $\Gamma \cup \Lambda \models_{\text{taut}}\varphi$}{
    \begin{itemize}
        \item Let $\Gamma \vdash \varphi$ and $v$ be a truth assigment that satiesfies every element in $\Gamma \cup \Lambda$. Induction on deduction of $\varphi$ from $\Gamma$.
            \begin{itemize}
                \item if $\varphi \in \Gamma\cup \Lambda$ then we are done
                \item if $\varphi$ is obtained from $\alpha$, $\alpha\to \varphi$ by MP then $v$ satiesfies $\alpha$ and $\alpha \to \varphi$
                
                $\{\alpha, \alpha\to \varphi \} \models_{\text{taut}} \varphi$
            \end{itemize}
        \item Assume $\Gamma \cup \Lambda \models_{\text{taut}}\varphi$. Then by the compactness theorem for propositional logic there are $\gamma_1\dots, \gamma_n\in\Gamma$ and $\lambda_1,\dots \lambda_m\in\Lambda$ such that
            \[\gamma_1\to \gamma_2\to \dots \to \gamma_n \to \lambda_1\to \dots \to \lambda_m\]
            is a tautology (always grouped to the left) because $\Gamma \cup \{\alpha\}\models_{\text{taut}}\beta$ iff $\Gamma \models_{\text{taut}}(\alpha \to \beta)$
    \end{itemize}
}
\section{Generalization and deduction theorem}
\note{}{Intuativly if $\Gamma$ does not assume anything about $x$ and $\Gamma$ proves $\varphi$ then $\Gamma$ proves $\forall x \varphi$}
\prop{Generalization theorem}{If $\Gamma \vdash \varphi$ and $x$ does not occur free in $\Gamma$, then $\Gamma \vdash \forall x \varphi$}{
    We use axiom group 4, $\alpha \to \forall x \alpha$ if $x$ is not occuring free in $\alpha$.
    Since $x$ does not occur free in $\sigma\in\Gamma$, if $\varphi \in \Thm \Gamma$ then $\forall x \varphi \in \Thm \Gamma$.
    Induction principle:
    $S$ the set of flas. If $\Lambda\cup \Gamma\subseteq S$ and $S$ is closed under MP then $S$ contains $\Thm (\Gamma)$.
    It is enough to show that $\{\varphi: \Gamma \vdash \forall x \varphi\}$ contains $\Gamma \cup \Lambda$.
    and is closed under MP.
    \begin{enumerate}
        \item if $\varphi$ is a logical axiom then $\forall x \varphi$ is a generalization and therefore also a logical axiom, so $\Gamma \vdash \forall x \varphi$
        \item Lets assume $\varphi in \Gamma$. then $x$ does not occur free in any element of $\Gamma$, then $\varphi \to \forall x \varphi$ is a logical axiom and $\Gamma \vdash \forall x \varphi$ by MP.
        \item Closedness under MP. suppose $\varphi$ is obtained from $\psi$, $\psi \to \varphi$ by MP. Then by induction hyphothesis $\Gamma \vdash \forall x \psi$ and $\Gamma \vdash \forall x (\psi  \to \varphi)$
        Then $\forall x (\psi \to \varphi) \to (\forall x \psi \to \forall x \varphi)$ is a logical axiom in group 3.
        Then by MP $\Gamma \vdash \forall x \psi \to \forall x \varphi$\\
        By MP again $\Gamma \vdash \forall x \varphi$
    \end{enumerate}
}
\note{}{Suppose $x$ has free occurence in $\Gamma$ 
    for example $Px \nvDash \forall x Px$ so we can not have $Px \vdash \forall x Px$ (want $\models$ iff $\vdash$)
}
\note{}{
    Proof of Generalization theorem can be used to obtain a deduction of $\forall x \varphi$ from $\Gamma$ from a deduction of $\varphi$ from $\Gamma$.
}
\lemma{Rule T}{If $\Gamma\vdash \alpha_1$, $\Gamma\vdash \alpha_2$,\dots $\Gamma\vdash \alpha_n$ and $\{alpha_1,\alpha_2,\dots \alpha_n\}\models_{\text{taut}}\beta$ then $\Gamma \vdash \beta$. }{
    $\alpha_1\to \alpha_2 \to \dots \to \alpha_n \to \beta$ is a logical axiom because it is a tautology.
    Apply MP $n$-times.
}
\prop{Deduction theorem}{If $\Gamma \cup \{\gamma\}\vdash \varphi$ then $\Gamma \vdash (\gamma \to \varphi)$}{
    Assume $\Gamma \cup \{\gamma\}\vdash \varphi$.
    $\Gamma \cup \{\gamma\}\vdash \varphi$ iff $\Gamma \cup \{\gamma\}\cup \Lambda \models_{\text{taut}} \varphi$ \\
    iff $\Gamma \cup \Lambda \models_{\text{taut}} \gamma \to \varphi$ (exercise sheet 1, ex 7)\\
    iff $\Gamma \vdash (\gamma \to \varphi)$
}
\note{}{Deduction theorem is an equivalence. $\Gamma \vdash \gamma \to \varphi$ then $\Gamma \cup \{\gamma\}\vdash \gamma$. the statement follows by MP.}


\coroll{(Contraposition): If $\Gamma\cup \{\varphi\}\vdash \lnot \psi$ then $\Gamma\cup \{\psi\}\vdash \lnot \varphi$ }
\begin{proof}
    Suppose $\Gamma\cup \{\varphi\}\vdash \lnot \psi$ then by deduction theorem $\Gamma \vdash \varphi\to \lnot \psi$
    We observe that $\{\varphi \to \lnot \psi\}\models_{\text{taut}} \psi \to \lnot \varphi$.

    By rule T: $\Gamma \vdash \psi \to \lnot \varphi$ and by the converse of the deduction theorem, by MP we have $\Gamma\cup \{\psi\}\vdash \lnot \varphi$
\end{proof}


\defin{}{A set of flas. $\Gamma$ is called inconsistent, if for some (euqivalent to all) fla. $\beta$ it is $\beta, \lnot \beta \in \Thm \Gamma$.}
\note{}{If $\Gamma$ is inconsistent, then for $\alpha\in \Thm \Gamma$.
Then $(\beta \to (\lnot \beta \to \alpha))$ is a tautology. Use $\beta$ from definition of inconsistence and use MP twice.
}

\coroll{(Reductio ad absurdum): If $\Gamma;\varphi$ inconsistent, then $\Gamma \vdash \lnot \varphi$.}
\begin{proof}
    Suppose that $\Gamma;\varphi$ is inconsistent. then for any $\beta$ $\Gamma;\varphi\vdash \beta$ and $\Gamma;\varphi\vdash \lnot \beta$ 
    By the deduction theorem $\Gamma\vdash \varphi\to \beta$ and $\Gamma\vdash \varphi\to \lnot \beta$, therefore 
    $\{\varphi \to \beta, \varphi \to \lnot \beta \}\models_{\text{taut}} \lnot \varphi$
    By Rule T: $\Gamma \vdash \lnot \varphi$.
\end{proof}

\note{}{strategies for finding deductions can be found in the textbook \cite{EndertonHerbertB2001AMIt}.}
\prop{Generalization on constants}{
    Suppose $\Gamma \vdash \varphi$ and $c$ is a constant symbol that does not occur in $\Gamma$.
    Then there is a variable $y$ ($y$ does not occur in $\varphi$) s.th. $\Gamma \vdash \forall y (\varphi)^c_y$.
    and moreover also there is a deduction of $\forall y (\varphi)^c_y$ in which $c$ does not occur.
}{
    We will take a deduction $\langle\alpha_1,\dots \alpha_n \rangle$ of $\varphi$ from $\Gamma$. 
    Pick the variable $y$ as the first variable in any $\alpha_i$ for each $i$.
    \graybf{Claim:} $\langle(\alpha_1)^c_y,\dots (\alpha_n)^c_y \rangle$ is a deduction of $(\varphi)^c_y$ from $\Gamma$.
    \begin{claimproof}
        We need to verify that every member $(\alpha)^c_y$ is actually provable from $\Gamma$.
        \begin{itemize}
            \item if $\alpha_k\in\Gamma$ then $c$ does not occur in $\alpha_k$ then $(\alpha)^c_y = \alpha_k$
            \item if $\alpha_k\in \Lambda$ then $(\alpha_k)^c_y$ is also a logical axiom.
            \item lets say $\alpha_k$ was obtained by $\alpha_i$, $\alpha_i \to \alpha_k$ $i<k$ by MP.
            Now take $(\alpha_i \to \alpha_k)^c_y = (\alpha_i)^c_y\to (\alpha_k)^c_y$. (induction hyphothesis) $(\alpha_k)^c_y$ is obtained from $(\alpha_i)^c_y$ nad $(\alpha_i \to \alpha_k)^c_y$.
            by MP. 
        \end{itemize}
    \end{claimproof}
    Because formal proofs are finite, there is a $\Gamma_0\subseteq \Gamma$ finite such that $\Gamma_0$ consists of the elements of $\Gamma$ used in our deduction 
    $\langle(\alpha_1)^c_y,\dots (\alpha_n)^c_y \rangle$ (is therefore deduction of $(\varphi)^c_y$ from $\Gamma_0$).
    And because we assumed that $y$ does not occur in $\Gamma_0$, so we can use the generalization theorem on $\Gamma_0\vdash (\varphi)^c_y$ and yield $\Gamma_0\vdash \forall y (\varphi)^c_y$ 
}
\subsubsection{Alphpabetic Variants}
We will formalize and proof the statement "You can always rename your bound variables".
Why is that impoirtant? Suppose we want to proof that it is provable that 
$\forall x \forall y P(x,y)\to \forall y P(y,y)$
If we want to use a logical axiom of group 2, we would need to check if $y$ is actually SA for $x$. We obviously do not have that because $y$ would get bounded.
$\vdash \forall x \forall y P(x,y) \to \forall x \forall z P(x,z)$ 
$\vdash \forall x \forall z P(x,z) \to \forall y P(y,y)$ 
\prop{Existence of alphabetic variants}{
    Let $\varphi$ be a fla., $x$ a variable, $t$ a term. Then there exists a fla. $\varphi'$ 
    such that $\varphi$ differs from $\varphi$ only in the choice of names of the bound variables.
    And \begin{enumerate}
        \item  $\varphi' \vdash \varphi$ as well as $\varphi \vdash \varphi'$
        \item $t$ is SA for $x$ in $\varphi'$
    \end{enumerate}
}{
    Define $\varphi'$ inductively on complexity of $\varphi$.
    \begin{itemize}
        \item if $\varphi$ is atomic, then $\varphi'= \varphi$
        \item $(\lnot \varphi)' = \lnot \varphi'$ \begin{enumerate}
            \item $\varphi' \vdash \varphi$ and $\varphi \vdash \varphi'$, we want: 
            $\lnot \varphi' \vdash \lnot \varphi$ as well as $\lnot \varphi \vdash \lnot \varphi'$
            Ok by Contraposition.
            \item ok by definition of SA
        \end{enumerate}
        \item $(\varphi \to \psi)' = \varphi' \to \psi'$
            \begin{enumerate}
                \item By assumption: 
                We want $(\varphi \to \psi )\vdash (\varphi \to \psi)'$, it is enough to show $\varphi \to \psi; \varphi' \vdash \psi'$
                We have \[\begin{aligned}
                    \varphi \to \psi &; \varphi' \vdash \varphi\\
                    \varphi \to \psi &; \varphi' \vdash \psi\\
                \end{aligned}\]
                \item ok by definition of SA
            \end{enumerate}
        \item $(\forall y \varphi)'$\begin{itemize}
            \item[Case 1:] No occurence of $y$ in $t$. or $x=y$ (that is, $t$ is substitutable for $x$ in $\varphi$). We define $(\forall y \varphi)' = \forall y \varphi'$. All we need to check is part (a). 
                We have that $\forall y \varphi \vdash \varphi$ because $\forall y \varphi \to \varphi$ is an axiom group 2.
                So $\forall y \varphi \vdash \varphi'$ and therefore by the generalization theorem $\forall x \varphi \vdash \forall y \varphi'$
            \item[Case 2:] If $y$ does occur in $t$ and $x\neq y$. let $z$ be the variable that is the first variable that does not occur in $\varphi', x, t$ then set
                $(\forall y \varphi)' = \forall z (\varphi')^y_z$
                \begin{enumerate}
                    \item[2.] want $t$ SA for $x$ in $(\forall y \varphi)'$ \\
                    $z$ does not occur in $t$ (choice of $z$)
                    $t$ is SA for $x$ in $\varphi'$. (ind assumption)
                    Then $t$ is SA fr $x$ in $\forall z (\varphi')^y_z$ iff $t$ is SA for $x$ in $(\varphi')^y_z$ because $x\neq z$.
                    \item[1.] $\varphi \vdash \varphi'$ (by ind. assumption)
                    Then $\forall y \varphi \vdash \forall y \varphi'$, because
                    \[\vdash \forall y (\varphi \to \varphi')\to (\forall y \varphi \to \forall y \varphi') \text{(axiom of group 3)}\]
                    then \[\forall y (\varphi \to \varphi')\text{gen thm}\]
                    and by MP: \[ \forall y \varphi \to \forall y \varphi'\]
                    
                    We have $\forall y \varphi' \vdash (\varphi')^y_z$ (axiom of group 2, z does not occur in $\varphi'$)
                    By Gen Thm. $\forall y \varphi' \vdash \forall z (\varphi')^y_z$
                    Then 


                    Want $\forall z (\varphi')^y_z \vdash \forall y \varphi$ \\
                    $\forall z (\varphi')^y_z \vdash ((\varphi')^y_z)^z_y$ (ax of group 2.), $y$ is SA for $z$ in $(\varphi')^y_z$ bc.
                    $\varphi'$ does not contain $z$ so all occurences of $z$ in $(\varphi')^y_z$ are free. (we substituted $z$ for free occ of $y$.)
                    (Re-replacement lemma $ ((\varphi')^y_z)^z_y = \varphi'$ , see problem set.)
                    So we have $\forall z (\varphi')^y_z\vdash \varphi$
                    We also know that $\varphi' \vdash \varphi$ by the inductive hyphothesis. 
                    So $\forall z (\varphi')^y_z \vdash \varphi$
                    So $\forall z (\varphi')^y_z \vdash \forall y \varphi$ (Gen Thm.)
                \end{enumerate}
        \end{itemize}
    \end{itemize}
}
\note{}{$\varphi'$ constructed in proof is also called an alphabetic variant of $\varphi$ }

if our language contains equality:
\begin{enumerate}
    \item $\vdash \forall x x = x$ (ax 5.)
    \item $\vdash \forall x \forall y (x=y \to y = x)$ p.122
    \item $\vdash \forall x \forall y \forall z (x=y \to (y=z \to x = z))$ (Exercise 11. in \cite{EndertonHerbertB2001AMIt})
    \item $\vdash \forall x_1 \forall x_2 \forall y_1 \forall y_2 (x_1=y_1 \to (x_2=y_2 \to (Px_1x_2 \to Py_1y_2)))$, similarly for any $n$-ary predicate. p.128
    \item $\vdash \forall x_1 \forall x_2 \forall y_1 \forall y_2 (x_1=y_1 \to (x_2 = y_2 \to (fx_1x_2 = fy_1y_2)))$, similarly for $n$-ary formula symbol, p.122
\end{enumerate}


\section{Soundness and completeness of first-order logic}

\begin{itemize}
    \item soundness: If $\Gamma \vdash \varphi$ then $\Gamma \models \varphi$
    \item completeness: If $\Gamma \models \varphi$ then $\Gamma \vdash \varphi$
\end{itemize}

In order to proof that all axioms are valid, we need the following two lemmas.
\lemma{pre-substitution lemma}{Let be a map TODO}{}
\lemma{Substitution lemma}{If $t$ SA $x$ in $\varphi$ then $\mathfrak{A}\models \varphi_t^x\: [s]$ iff $\mathfrak{A}\models \varphi\: [s(x|\overline{s}(t))]$}{
    \begin{enumerate}
        \item $\varphi$ atomic: use pre-substitution lemma.
        \item $\varphi$ is of the form $\lnot \psi$ or $\psi \to \theta$ - use induction
        \item $\varphi$ is of the form $\forall y \psi $ and $x$ does not occur free in $\varphi$\\
        $\varphi^x_t = \varphi$ wts. $\mathfrak{A}\models \varphi_t^x\: [s]$ iff $\mathfrak{A}\models \varphi\: [s(x|\overline{s}(t))]$\\
        By \ref{Thm.evalonlyfreevar}, this is indeed the case, so the lemma holds.
        \item $\varphi$ is $\forall y \psi$ where $x$ occurs free in $\varphi$ and $t$ is SA for $x$ in $\varphi$.
        Then it must be: $y$ does not occur in $t$ and $t$ is SA for $x$ in $\psi$.\\
        then $\overline{s}(t) = \overline{s(y|a)}(t)$ for every $a\in A$. Moreover we also have, that $\varphi^x_t = \forall y \psi^x_t$ bc. $x\neq y$\\
        Then $\mathfrak{A}\models \varphi_t^x \: [s]$ iff $\mathfrak{A}\models \forall y \psi_t^x \: [s]$\\
        iff $\mathfrak{A}\models \psi_t^x \: [s(y|a)]$ and for all $a\in A$.\\
        iff $\mathfrak{A}\models \psi \: [s(y|a)(x|\overline{s(y|a)}(t))]$ (inductive assumption) and for all $a\in A$\\
        By above: iff $\mathfrak{A}\models \psi \: [s(y|a)(x|\overline{s}(t))]$ for all $a\in A$\\
        iff $\mathfrak{A}\models \forall y \psi \: [s(x|\overline{s}(t))]$
    \end{enumerate}
}


\prop{}{If $\Gamma \vdash \varphi$ then $\Gamma \models \varphi$}{
    Proof by induction on $\varphi$.
    We have to show: 
    \begin{enumerate}
        \item that every logical axiom is valid
        \item logical implication is preserved by MP
    \end{enumerate}
    \begin{enumerate}
        \item[2.] Assume 1. we have to show that if  $\Gamma \vdash \varphi$ then $\Gamma \models \varphi$
        \begin{itemize}
            \item $\varphi\in \Lambda$ by 1.
            \item $\varphi \in \Gamma$ then $\Gamma \models \varphi$
            \item $\varphi$ follows by MP from $\psi,\psi \to \varphi$ then by assumption $\Gamma\models \psi$ and $\Gamma\models \psi \to \varphi$
            Therefore $\Gamma\models \varphi$
        \end{itemize}
        \item[1.] Exercise 6 in section 2.2 consists in showing that if a logical axiom is valid, then also its generalization.
        So generalizations of valid formulas are valid, we therefore may only consider logical axioms that are not generalizations of another logical axiom.
        \begin{enumerate}
            \item[Ax of 1.] exercise 3, section 2.3
            \item[3.] exercise 3, section 2.2
            \item[4.] exercise 4, section 2.2
            \item[5.] $x=x$: $\mathfrak{A}\models x = x[s]$ because $s(x) = s(x)$
            \item[6.] $x=y \to (\alpha \to \alpha')$ where $\alpha$ is atomic fla, and $\alpha'$ is obtained from $\alpha$ by remplacing some occurances of $x$'s with $y$'s.
            By the deduction theorem, is enough to show that the set of formulas $\{x=y, \alpha\}\models \alpha'$.
            Let $\mathfrak{A}$ be a structure, $s$ an assigment such that $\mathfrak{A}\models x=y [s]$
            \graybf{Claim: } for every term $t$ if $t'$ is obtained from $t$ by replacing some $x$'s by $y$'s, then $\overline{s}(t) = \overline{s}(t')$.
            \begin{claimproof}
                Induction on terms.
            \end{claimproof}
            \begin{itemize}
                \item $\alpha$ of the form $t_1 = t_2$ then $\alpha'$ is $t_1' =t_2'$, use prev. claim.
                \item $\alpha$ of the form $P t_1 \dots t_n$ similar
            \end{itemize}
            \item[2.] wts. $\forall x \varphi \to \varphi^x_t$ is valid, where $t$ is SA for $x$ in $\varphi$.\\
            simple case: $\forall x Px \to Pt$ is valid.
            Let $\mathfrak{A}\models \forall x P x [s]$ then $\mathfrak{A}\models \forall x P x [s(x|a)]$ for every $a\in A$. so i.p. for $a = \overline{s}(t)$
            this means $\overline{s}(t)\in P^\mathfrak{A}$ that is $\mathfrak{A}\models Pt$.
            In more generality we will need the substitution lemma:
            We have $\mathfrak{A} \models \forall x \varphi \: [s]$\\
            this is equivalent to $\forall a \in A$ we have $\mathfrak{A}\models \varphi [s(x|a)]$ 
            then in particular $\mathfrak{A}\models \varphi [s(x|\overline{s}(t))]$ and
            by the substitution lemma we have the equivalence to $\mathfrak{A}\models \varphi^x_t\:[s]$
        \end{enumerate}
    \end{enumerate}
}



